<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>computación on datanalytics</title>
    <link>/tags/computaci%C3%B3n/</link>
    <description>Recent content in computación on datanalytics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Wed, 14 Jul 2021 09:13:00 +0000</lastBuildDate><atom:link href="/tags/computaci%C3%B3n/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mi apuesta para el larguísimo plazo: Julia</title>
      <link>/2021/07/14/mi-apuesta-para-el-larguisimo-plazo-julia/</link>
      <pubDate>Wed, 14 Jul 2021 09:13:00 +0000</pubDate>
      
      <guid>/2021/07/14/mi-apuesta-para-el-larguisimo-plazo-julia/</guid>
      <description>Larguísimo, arriba, significa algo así como 10 o 20 años. Vamos, como cuando comencé con R allá por el 2001. * R es, reconozcámoslo, un carajal. Pocas cosas mejores que esta para convencerse. * No dejo de pensar en aquello que me dijo un profesor en 2001: que R no podría desplazar a SAS porque no tenía soporte modelos mixtos. Yo no sabía qué eran los modelos mixtos en esa época pero, desde entonces, vine a entender y considerar que &amp;ldquo;tener soporte para modelos mixtos&amp;rdquo; venía a ser como aquello que convertía a un lenguaje para el análisis de datos en una alternativa viable y seria a lo existente.</description>
    </item>
    
    <item>
      <title>¿Modelos para ordenar datos?</title>
      <link>/2020/10/22/modelos-para-ordenar-datos/</link>
      <pubDate>Thu, 22 Oct 2020 09:13:00 +0000</pubDate>
      
      <guid>/2020/10/22/modelos-para-ordenar-datos/</guid>
      <description>Ayer leí este resumen de este artículo que propone y discute un algoritmo novedoso y basado en ciencia de datos para ordenar datos y hacerle la competencia a quicksort y demás. Reza y promete:
La idea fundamental del algoritmo consiste en crear un modelo que estime (aproximadamente, claro está) dónde quedaría cada observación una vez ordenados los datos además de, obviamente, una discusión sobre cómo solucionar los errores de predicción.</description>
    </item>
    
    <item>
      <title>BLAS, eficiencia y lme4</title>
      <link>/2019/10/02/blas-eficiencia-y-lme4/</link>
      <pubDate>Wed, 02 Oct 2019 09:13:30 +0000</pubDate>
      
      <guid>/2019/10/02/blas-eficiencia-y-lme4/</guid>
      <description>Cada cierto número de años me reencuentro con la cuestión de BLAS, ATLAS y todas esas cosas por tratar de arañar un poco de eficiencia a R.
Existen el BLAS de toda la vida que, parece ser, viene de serie con R y uno puede optar por otras versiones optimizadas como ATLAS u OpenBLAS, cuyas ventajas relativas, de acuerdo con estos benchmarks, no parecen demasiado claras.
Lo novedoso en esta revisita al problema es que he aprendido que a los anteriores se han sumado en estos últimos años, cuando menos:</description>
    </item>
    
    <item>
      <title>Todo lo que sucede en R es una llamada a una función</title>
      <link>/2017/03/16/todo-lo-que-sucede-en-r-es-una-llamada-a-una-funcion/</link>
      <pubDate>Thu, 16 Mar 2017 15:44:30 +0000</pubDate>
      
      <guid>/2017/03/16/todo-lo-que-sucede-en-r-es-una-llamada-a-una-funcion/</guid>
      <description>En serio, es así. ¿También if? Pues también. De hecho,
`if`(1 == 3, print(&amp;quot;a&amp;quot;), print(&amp;quot;b&amp;quot;))  Y eso permite, por ejemplo, que funcionen expresiones tales como
a &amp;lt;- if (1 == 3) 4 else 5  tan útiles como poco empleadas en general. También son funciones (, { y otras que aparecen en la sección .Internal vs .Primitive del documento R Internals.</description>
    </item>
    
    <item>
      <title>Una fina, tenue, somera capa de sintaxis</title>
      <link>/2016/11/15/una-fina-tenue-somera-capa-de-sintaxis/</link>
      <pubDate>Tue, 15 Nov 2016 08:13:18 +0000</pubDate>
      
      <guid>/2016/11/15/una-fina-tenue-somera-capa-de-sintaxis/</guid>
      <description>Estuve el otro día en una charla de José Luis Cañadas en el grupo de usuarios de R de Madrid sobre sparklyr. Hoy en otra de Juan Luis Rivero sobre, esencialmente, lo mismo, pero esta vez con Python. Y podría escribir &amp;ldquo;etc.&amp;rdquo;.
Me centraré en la de José Luis, aunque podría decir lo mismo de cualquiera de las otras. No había trabajado con sparklyr. No soy siquiera fan de dplyr (aunque no es que no se lo recomiende a otros; es simplemente, como tantas cosas, que soluciona problemas que no tengo).</description>
    </item>
    
    <item>
      <title>R es un vago</title>
      <link>/2016/06/27/r-es-un-vago/</link>
      <pubDate>Mon, 27 Jun 2016 08:13:56 +0000</pubDate>
      
      <guid>/2016/06/27/r-es-un-vago/</guid>
      <description>Si creo la función
foo &amp;lt;- function(a,b) a*a + b  y la llamo mediante
foo(1 + 1,3)  pueden ocurrir dos cosas: o bien que R precalcule 1+1 y la función ejecute 2 * 2 + 3 o bien que la función ejecute directamente (1+1)*(1+1)+3. Pero, ¿qué es lo que hace realmente? Si escribimos
f1 &amp;lt;- function(x){ print(&amp;quot;Soy f1&amp;quot;) x } f2 &amp;lt;- function(x){ print(&amp;quot;Soy f2&amp;quot;) x } foo(f1(2), f2(3))  obtenemos</description>
    </item>
    
    <item>
      <title>¿Tanto ha llovido (en términos de precisión numérica) desde 2008?</title>
      <link>/2016/05/24/tanto-ha-llovido-en-terminos-de-precision-numerica-desde-2008/</link>
      <pubDate>Tue, 24 May 2016 08:13:42 +0000</pubDate>
      
      <guid>/2016/05/24/tanto-ha-llovido-en-terminos-de-precision-numerica-desde-2008/</guid>
      <description>Acabo de ejecutar
&amp;lt;a href=&amp;quot;http://inside-r.org/r-doc/base/set.seed&amp;quot;&amp;gt;set.seed(1234) x &amp;lt;- runif(1e6) x.shift &amp;lt;- 1e9 + x sd(x) sd(x.shift) sqrt(sum((x - mean(x))^2) / (length(x - 1))) sqrt(sum((x.shift - mean(x.shift))^2) / (length(x - 1))) sd.sum.squares &amp;lt;- function(x){ n &amp;lt;- length(x) suma &amp;lt;- sum(x) suma.cuadrados &amp;lt;- sum(x^2) sqrt((n * suma.cuadrados - suma^2) / (n * (n-1))) } sd.sum.squares(x) sd.sum.squares(x.shift)  inspirado por esto y me pregunto: ¿tanto ha llovido en términos de precisión numérica desde 2008?</description>
    </item>
    
    <item>
      <title>Tengo ordenador nuevo con 64GB de RAM (más unas preguntas)</title>
      <link>/2016/05/23/tengo-ordenador-nuevo-con-64gb-de-ram-mas-unas-preguntas/</link>
      <pubDate>Mon, 23 May 2016 08:13:37 +0000</pubDate>
      
      <guid>/2016/05/23/tengo-ordenador-nuevo-con-64gb-de-ram-mas-unas-preguntas/</guid>
      <description>Sí, mi viejo ordenador había cumplido 6 años y comenzaba a quedarse corto. La puntilla fueron problemas de compatibilidad de la tarjeta gráfica con el nuevo Xubuntu (más precisamente, con los nuevos núcleos de Linux que trae). Así que lo que hace no tanto habría parecido ciencia ficción, es ahora realidad bajo mi mesa: 64GB de RAM para mí solo. Y eso que no me he querido gastar dinero; además que, como autónomo y siendo la nueva máquina herramienta de trabajo, viene a salirme como en la mitad que a un civil.</description>
    </item>
    
    <item>
      <title>Hoy es el día mundial de la copia de seguridad</title>
      <link>/2015/03/31/hoy-es-el-dia-mundial-de-la-copia-de-seguridad/</link>
      <pubDate>Tue, 31 Mar 2015 08:13:45 +0000</pubDate>
      
      <guid>/2015/03/31/hoy-es-el-dia-mundial-de-la-copia-de-seguridad/</guid>
      <description>Así que ya sabéis qué tenéis que hacer.
Nota: el día mundial de la copia de seguridad es una iniciativa independiente (de, entre otros, fabricantes de discos duros). No forma parte de la lista oficial de días mundiales. Pero es infinitamente más importante y menos chorra que la mayor parte de ellos.</description>
    </item>
    
    <item>
      <title>Paralelización en R con snow</title>
      <link>/2014/12/03/paralelizacion-en-r-con-snow/</link>
      <pubDate>Wed, 03 Dec 2014 07:13:13 +0000</pubDate>
      
      <guid>/2014/12/03/paralelizacion-en-r-con-snow/</guid>
      <description>Suelo trabajar un servidor con ocho CPUs. Cuando quiero paralelizar código en R, suelo utilizar [parallel::mclapply](https://stat.ethz.ch/R-manual/R-devel/library/parallel/html/mclapply.html) (como aquí). Pero no tengo una máquina. Tengo varias. Y antes, de hecho, muchas.
¿Cómo paralelizar en distintas máquinas?
Se puede usar Spark (y SparkR), por ejemplo. Pero una ruta que no había ensayado jamás es la de la vieja escuela, i.e., MPI, snow y demás.
Pero si
 * tienes varios servidores corriendo un sistema operativo decente, * instalas R y `snow` (y todo lo que necesites) en todos ellos y * configuras los servidores para poder acceder a través de [ssh sin contraseña](http://www.</description>
    </item>
    
    <item>
      <title>Mascotas y rebaños</title>
      <link>/2014/08/15/mascotas-y-rebanos/</link>
      <pubDate>Fri, 15 Aug 2014 07:13:22 +0000</pubDate>
      
      <guid>/2014/08/15/mascotas-y-rebanos/</guid>
      <description>Muchos cuidamos de nuestro ordenador casi como una mascota: le ponemos un nombre (a menudo escribo desde tiramisu), le hacemos algo de mantenimiento, etc. Hay quienes, incluso, decoran sus máquinas con pegatinas.
Pero llega un momento en que hay que comenzar a tratar a las máquinas no tanto como mascotas sino como rebaños. Desde una pantalla aneja a esta en la que escribo estoy manejando un clúster de más de 200 GB y 50 núcleos distribuido en varias máquinas que ni sé dónde están.</description>
    </item>
    
    <item>
      <title>Dos citas de 1983 sobre estadística y métodos computacionales</title>
      <link>/2014/06/23/dos-citas-de-1983-sobre-estadistica-y-metodos-computacionales/</link>
      <pubDate>Mon, 23 Jun 2014 07:27:45 +0000</pubDate>
      
      <guid>/2014/06/23/dos-citas-de-1983-sobre-estadistica-y-metodos-computacionales/</guid>
      <description>Rescato aquí para mis lectores dos citas de un artículo de 1983, Computer Intensive Methods in Statistics, de Efron y Diaconis, por dos motivos: su valor intrínseco y que consideren leer el resto, particularmente el principio y el final.
La primera es (con mi traducción):
Y la segunda:
Sin otros comentarios que los vuestros.</description>
    </item>
    
    <item>
      <title>Imágenes y magia</title>
      <link>/2014/05/16/imagenes-y-magia/</link>
      <pubDate>Fri, 16 May 2014 07:14:27 +0000</pubDate>
      
      <guid>/2014/05/16/imagenes-y-magia/</guid>
      <description>No sé si imagen y magia comparten la misma raíz. Lo que me consta es que la gente que procesa imágenes hace algo que me parece casi mágico. De mayor quiero ser como ellos.
Traigo aquí un ejemplo sobre técnicas para completar imágenes:

El artículo completo, Scene Completion Using Millions of Photographs, y mucho material auxiliar puede revisarse aquí.</description>
    </item>
    
    <item>
      <title>¿Cinco años y salen sin programar?</title>
      <link>/2014/04/28/cinco-anos-y-salen-sin-programar/</link>
      <pubDate>Mon, 28 Apr 2014 07:42:00 +0000</pubDate>
      
      <guid>/2014/04/28/cinco-anos-y-salen-sin-programar/</guid>
      <description>Sí, hay gente que pasa cinco años en una de esas instituciones encopetadas que son las universidades y sale de ellas sin saber programar.
Aquí va un ejemplo. Es un fragmento de un currículo que me ha llegado recientemente. El tipo es economista, graduado en uno de los departamentos de la materia más reconocidos de Madrid. Dice así:

Eso es todo lo que el tipo reconoce saber sobre algo parecido a la programación.</description>
    </item>
    
    <item>
      <title>El lenguaje de Wolfram (según Wolfram)</title>
      <link>/2014/04/04/el-lenguaje-de-wolfram-segun-wolfram/</link>
      <pubDate>Fri, 04 Apr 2014 07:45:34 +0000</pubDate>
      
      <guid>/2014/04/04/el-lenguaje-de-wolfram-segun-wolfram/</guid>
      <description>En el siguiente vídeo Wolfram habla del lenguaje de Wolfram. Siento repetirme, pero quiero dejar claro que puede haber un sesgo. Porque como no lo haya, el Sr. Wolfram me va a tener como admirador (y puede que hasta como cliente).
Mirad lo que cuenta:
https://www.youtube.com/watch?v=_P9HqHVPeik
¿Es o no casi increíble?</description>
    </item>
    
    <item>
      <title>Predictores con varianza casi nula, inflación, loterías y línea de comandos</title>
      <link>/2014/03/28/predictores-con-varianza-casi-nula-inflacion-loterias-y-linea-de-comandos/</link>
      <pubDate>Fri, 28 Mar 2014 07:08:40 +0000</pubDate>
      
      <guid>/2014/03/28/predictores-con-varianza-casi-nula-inflacion-loterias-y-linea-de-comandos/</guid>
      <description>Hoy viernes vuelvo a traer a mis páginas cuatro enlaces interesantes. El primero de ellos es como las malas películas: un arranque espléndido, un planteamiento prometedor y, al final, humo. Pero no trata de chico-conoce-chica sino de qué hacer con esas variables que tienen una varianza casi nula (a la hora de crear modelos estadísticos, se entiende). Me llegó tan oportunamente que pensé que alguien que vela por mí desde lo alto me lo enviaba para sacarme de mi semanal atolladero.</description>
    </item>
    
    <item>
      <title>Mis copias de seguridad</title>
      <link>/2013/08/21/mis-copias-de-seguridad/</link>
      <pubDate>Wed, 21 Aug 2013 07:14:31 +0000</pubDate>
      
      <guid>/2013/08/21/mis-copias-de-seguridad/</guid>
      <description>Por referencia mía y de otros, voy a dejar acá escrito y explicado cómo gestiono mis copias de seguridad. Porque los discos duros se rompen y los ordenadores desaparecen. Etc.
Primero, mi instalación: tengo un ordenador de bajomesa (tiramisu) y un netbook (kropotkin). Ambos corren la misma versión de Xubuntu, la última estable.
Mi primera línea de defensa contra las pérdidas de información es la sincronización de ambas máquinas. Aquellos directorios que contienen cosas que no quiero perder (documentos, fotos, código, ¡copias de seguridad de otras máquinas, incluido esto que lees ahora!</description>
    </item>
    
    <item>
      <title>Mi definición de &#34;big data&#34;</title>
      <link>/2013/07/10/mi-definicion-de-big-data/</link>
      <pubDate>Wed, 10 Jul 2013 07:33:03 +0000</pubDate>
      
      <guid>/2013/07/10/mi-definicion-de-big-data/</guid>
      <description>No sin descaro, me atrevo a aportar una definición alternativa a eso que llaman big data y que yo traduzco en ocasiones como grandes datos.
No obstante, para comprenderla, considero necesaria una pequeña digresión de dos párrafos —con la que muchos, espero, no aprenderán nada que no traigan ya sabido— sobre los lenguajes de programación declarativos e imperativos.
En los primeros, programar consiste esencialmente en escribir con cierta notación aquello que quieres: la suma de los elementos de un vector, el promedio de los valores de una columna de una tabla, la suma de los saldos de los clientes de Soria, etc.</description>
    </item>
    
    <item>
      <title>data.table (II): agregaciones</title>
      <link>/2013/05/09/data-table-ii-agregaciones/</link>
      <pubDate>Thu, 09 May 2013 07:52:45 +0000</pubDate>
      
      <guid>/2013/05/09/data-table-ii-agregaciones/</guid>
      <description>Sigo con mi lacónica serie sobre data.table.
La protagonista:
frases[sample(1:nrow(frases), 3),] #pos.es pos.en length.es length.en en es frase tfe qjilm num #1: 15 43 72 72 i de 2632 4.881416e-02 0.01369863 6.686871e-04 #2: 33 48 46 48 X países 5321 2.726146e-06 0.02040816 5.563563e-08 #3: 2 35 53 66 in preguntar 4582 2.424379e-08 0.01492537 3.618476e-10 dim(frases) #[1] 6340091 10  El tiempo:
system.time({ setkey(frases, &amp;quot;frase&amp;quot;, &amp;quot;es&amp;quot;) denominadores &amp;lt;- frases[, sum(num), by = key(frases)] setnames(denominadores, c(&amp;quot;frase&amp;quot;, &amp;quot;es&amp;quot;, &amp;quot;den&amp;quot;) ) frases &amp;lt;- merge(frases, denominadores) frases$delta &amp;lt;- frases$num / frases$den }) #user system elapsed #5.</description>
    </item>
    
    <item>
      <title>Dependencias funcionales en R con foodweb</title>
      <link>/2013/05/08/dependencias-funcionales-en-r-con-foodweb/</link>
      <pubDate>Wed, 08 May 2013 07:17:59 +0000</pubDate>
      
      <guid>/2013/05/08/dependencias-funcionales-en-r-con-foodweb/</guid>
      <description>El otro día tropecé con un problema de rendimiento con R y al utilizar Rprof() encontré muchas llamadas a funciones que yo no hacía directamente.
La principal sospechosa era la función daply (del paquete plyr) que parecía depender de bastantes otras. Uno puede navegar el código de las funciones para identificar esas dependencias, pero, mirad qué maravilla:
library(&amp;lt;a href=&amp;quot;http://inside-r.org/packages/cran/mvbutils&amp;quot;&amp;gt;mvbutils) library(&amp;lt;a href=&amp;quot;http://inside-r.org/packages/cran/plyr&amp;quot;&amp;gt;plyr) foodweb(find.funs(&amp;quot;package:plyr&amp;quot;), &amp;lt;a href=&amp;quot;http://inside-r.org/r-doc/rpart/prune&amp;quot;&amp;gt;prune = &amp;quot;laply&amp;quot;)  genera

Ahí se ve la dependencia de daply con respecto a laply.</description>
    </item>
    
    <item>
      <title>data.table (I): cruces</title>
      <link>/2013/05/02/data-table-i-cruces/</link>
      <pubDate>Thu, 02 May 2013 07:16:30 +0000</pubDate>
      
      <guid>/2013/05/02/data-table-i-cruces/</guid>
      <description>Los protagonistas (tres tablas grandecitas):
dim(qjilm) # [1] 3218575 5 dim(tf) # [1] 6340091 7 dim(tfe) #[1] 1493772 3 &amp;lt;a href=&amp;quot;http://inside-r.org/r-doc/utils/head&amp;quot;&amp;gt;head(qjilm, 2) #pos.es length.en length.es pos.en qjilm #1 1 2 1 1 0.8890203 #2 1 2 1 2 0.1109797 &amp;lt;a href=&amp;quot;http://inside-r.org/r-doc/utils/head&amp;quot;&amp;gt;head(tf, 2) #frase es pos.es length.es en pos.en length.en #1 996 ! 42 42 ! 43 44 #2 1231 ! 37 37 ! 37 38 &amp;lt;a href=&amp;quot;http://inside-r.org/r-doc/utils/head&amp;quot;&amp;gt;head(tfe, 2) #en es tfe #1 !</description>
    </item>
    
    <item>
      <title>Infografía sobre Big Data Spain</title>
      <link>/2012/12/18/infografia-sobre-big-data-spain/</link>
      <pubDate>Tue, 18 Dec 2012 07:17:20 +0000</pubDate>
      
      <guid>/2012/12/18/infografia-sobre-big-data-spain/</guid>
      <description>Rubén Martínez, viejo conocido (fue instrumental en la organización del concurso de análisis de datos de las III Jornadas de Usuarios de R) me ha hecho llegar la siguiente infografía sobre el estado del mundo de los grandes datos (big data) y, en particular, sobre las conferencias Big Data Spain en cuya organización colaboró. Es la siguiente (hay que hacer clic en ella para verla en tamaño completo):

Esperemos que el año que viene no coincida con las jornadas de R y podamos compatibilizar ambas&amp;hellip;</description>
    </item>
    
    <item>
      <title>Disponibles los vídeos de las sesiones de BigDataSpain</title>
      <link>/2012/12/05/disponibles-los-videos-de-las-sesiones-de-bigdataspain/</link>
      <pubDate>Wed, 05 Dec 2012 07:49:27 +0000</pubDate>
      
      <guid>/2012/12/05/disponibles-los-videos-de-las-sesiones-de-bigdataspain/</guid>
      <description>Ya están disponibles los vídeos de las sesiones de la conferencia BigDataSpain que anunciamos hace un tiempo en estas páginas.
http://www.youtube.com/watch?v=7efDRf4q3lk</description>
    </item>
    
    <item>
      <title>MapReduce con mincedmeat</title>
      <link>/2012/11/07/mapreduce-con-mincedmeat/</link>
      <pubDate>Wed, 07 Nov 2012 14:41:14 +0000</pubDate>
      
      <guid>/2012/11/07/mapreduce-con-mincedmeat/</guid>
      <description>Hace unos días implementé un proceso MapReduce usando mincedmeat, un pequeño entorno en Python para desarrollar este tipo de procesos distribuidos. El código y los datos pueden descargarse de este enlace.
Los datos de partida están en 249 ficheros de unos 25kb que contienen filas del tipo
journals/algorithmica/HarelS98:::David Harel::Meir Sardas:::An Algorithm for Straight-Line of Planar Graphs
es decir, publicación, autor (o autores) separados por :: y título de la publicación. Los tres campos están separados por :::.</description>
    </item>
    
    <item>
      <title>Predicciones de series temporales a gran escala y en paralelo con R</title>
      <link>/2012/09/25/predicciones-de-series-temporales-a-gran-escala-y-en-paralelo-con-r/</link>
      <pubDate>Tue, 25 Sep 2012 07:50:49 +0000</pubDate>
      
      <guid>/2012/09/25/predicciones-de-series-temporales-a-gran-escala-y-en-paralelo-con-r/</guid>
      <description>En el artículo Large-Scale Parallel Statistical Forecasting Computations in R encontrarán los interesados información sobre cómo está usando Google R para realizar predicciones de series temporales a gran escala usando cálculos en paralelo.
El artículo tiene dos partes diferenciadas. Por un lado está la que describe los métodos que usan para realizar predicciones sobre series temporales. Parecen sentir cierto desdén por la teoría clásica, comprensible dado el gran número de series temporales que tratan de predecir y el mimo —entiéndase como uso de materia gris— que exige aquella.</description>
    </item>
    
    <item>
      <title>El algoritmo PSLQ e identificación de números</title>
      <link>/2012/09/17/el-algoritmo-pslq-e-identificacion-de-numeros/</link>
      <pubDate>Mon, 17 Sep 2012 07:22:17 +0000</pubDate>
      
      <guid>/2012/09/17/el-algoritmo-pslq-e-identificacion-de-numeros/</guid>
      <description>El algoritmo PSLQ se usa para resolver aproximadamente ecuaciones con coeficientes enteros $latex a_i$ de la forma
$latex \sum_i a_i x_i = 0$
donde, obviamente, no todos los $latex a_i$ son cero. Aproximadamente significa que la solución se busca dentro de un cierto nivel de tolerancia.
No existe, que yo sepa, una implementación en R. Pero sí en Python, usando librerías que permiten utilizar números de precisión arbitraria, como [mpmath](https://code.google.com/p/mpmath/). Veamos un ejemplo:</description>
    </item>
    
    <item>
      <title>¿Varianza explicada?</title>
      <link>/2012/03/08/%c2%bfvarianza-explicada/</link>
      <pubDate>Thu, 08 Mar 2012 07:44:41 +0000</pubDate>
      
      <guid>/2012/03/08/%c2%bfvarianza-explicada/</guid>
      <description>Sin darnos cuenta, abusamos de ciertos términos. Uno de ellos es el de la varianza explicada. Después de años utilizándolo como por inercia, he venido a darme cuenta por dos vías distintas de su impropiedad: una de mis recientes lecturas y una experiencia profesional.
Tal vez sea más sencillo comenzar exponiendo la crítica realizada en esa página. Parte del análisis de la serie de muertes en Chicago entre 1987 y el 2000:</description>
    </item>
    
    <item>
      <title>Más sobre Julia (II): mi primer programa</title>
      <link>/2012/03/06/mas-sobre-julia-ii-mi-primer-programa/</link>
      <pubDate>Tue, 06 Mar 2012 08:37:57 +0000</pubDate>
      
      <guid>/2012/03/06/mas-sobre-julia-ii-mi-primer-programa/</guid>
      <description>A las entradas que he hecho sobre Julia estos últimos días, quiero añadir esta en la que publico mi primer programa en dicho lenguaje.
Me ha dado por reimplementar el programa para realizar un muestreo de Gibbs que aparece en Gibbs sampler in various languages.
Lo primero ha sido instalar Julia, para lo que basta con seguir las instrucciones que aparecen en su página de github. Y aviso: tarda bastante en descargar y compilar todas sus dependencias.</description>
    </item>
    
    <item>
      <title>Más sobre Julia</title>
      <link>/2012/03/05/mas-sobre-julia/</link>
      <pubDate>Mon, 05 Mar 2012 08:09:35 +0000</pubDate>
      
      <guid>/2012/03/05/mas-sobre-julia/</guid>
      <description>Unos días después de la primera noticia acerca de Julia en esta bitácora me llegan, como suele ser habitual en estos casos, otras.
En primer lugar, hay una discusión interesante sobre R en la lista de desarrolladores de Julia. Y hay un vídeo de Jeff Bezanson sobre Julia de un seminario en Stanford que podría estar pronto disponible en el canal de Youtube de dicha universidad (y que, de momento, puede verse yendo a la bitácora de Julia y después, navegando a Stanford Talk Video y available here).</description>
    </item>
    
    <item>
      <title>La función monotonic de PROC SQL de SAS</title>
      <link>/2010/11/11/la-funcion-monotonic-de-proc-sql-de-sas/</link>
      <pubDate>Thu, 11 Nov 2010 09:55:58 +0000</pubDate>
      
      <guid>/2010/11/11/la-funcion-monotonic-de-proc-sql-de-sas/</guid>
      <description>Previamente he hablado en este blog de las ventajas que ofrece PROC SQL en SAS sobre otros métodos más propiamente SAS de realizar ciertas manipulaciones de datos. Existen no obstante cierto tipo de manipulaciones que exigen pasos data: gran parte de las que hacen uso de la variable automática n.
No obstante, existe una función no documentada de SAS que permite implementar con SQL muchas operaciones de este tipo: monotonic.</description>
    </item>
    
    <item>
      <title>¿Siete lenguajes de programación emergentes?</title>
      <link>/2010/10/27/siete-lenguajes-de-programacion-emergentes/</link>
      <pubDate>Wed, 27 Oct 2010 22:21:05 +0000</pubDate>
      
      <guid>/2010/10/27/siete-lenguajes-de-programacion-emergentes/</guid>
      <description>Hace un par de días apareció un artículo en InfoWorld en el que se enumeraban siete lenguajes de programación emergentes. Parece que por emergentes ha de entenderse cada vez más extendidos en la empresa. Como R hacía parte del rol, comencé alegrándome. Después me surgieron dos elementos de sospecha.
Véase la lista de los siete lenguajes seleccionados:
 Python, un viejo conocido. Ruby Matlab JavaScript, que está gozando de una segunda primavera gracias a AJAX y demás R, ¡cómo no!</description>
    </item>
    
    <item>
      <title>El paquete multicore de R</title>
      <link>/2010/09/01/el-paquete-multicore-de-r/</link>
      <pubDate>Wed, 01 Sep 2010 22:24:44 +0000</pubDate>
      
      <guid>/2010/09/01/el-paquete-multicore-de-r/</guid>
      <description>Tengo acceso a una máquina que, aunque anda un poco corta de memoria, cuenta con ocho CPUs. Tenía unas simulaciones bastante pesadas que correr y quise aprovechar su naturaleza perfectamente paralelizable. Y, de paso, hacer con R lo mismo por lo que he visto a un consultor de SAS cobrar a razón de 3.000 dólares diarios.
En el fondo, es una trivialidad. Supongamos que la función que implementa la simulación se llama foo.</description>
    </item>
    
    <item>
      <title>Más de diez motivos para usar PROC SQL en SAS</title>
      <link>/2010/07/18/mas-de-diez-motivos-para-usar-proc-sql-en-sas/</link>
      <pubDate>Sun, 18 Jul 2010 16:01:59 +0000</pubDate>
      
      <guid>/2010/07/18/mas-de-diez-motivos-para-usar-proc-sql-en-sas/</guid>
      <description>Hace no mucho escribí una entrada en este blog sobre, bromas aparte, cómo no escribir código SAS. Habría respondido in situ a uno de los comentarios que hicieron mis lectores pero, abusando de mi condición de dueño del blog, lo voy a hacer desde más encumbrado púlpito: una entrada ad hoc. Conste que escribo para discrepar. Pero conste también que lo hago desde la más genuina cordialidad y con la esperanza de generar un debate que a todos nos enriquezca.</description>
    </item>
    
    <item>
      <title>Madre Teresa, patriotas, idiotas... y queries recursivas</title>
      <link>/2010/03/11/madre-teresa-patriotas-idiotas-y-queries-recursivas/</link>
      <pubDate>Thu, 11 Mar 2010 20:00:14 +0000</pubDate>
      
      <guid>/2010/03/11/madre-teresa-patriotas-idiotas-y-queries-recursivas/</guid>
      <description>No es éste foro para opinar sobre si nos interesa la Madre Teresa o si los patriotas son idiotas, pero sí para mostrar nuestro desacuerdo con la canción (por abreviar, acá está su letra) y dejar claro que las jerarquías no son una porquería. Si no que se lo digan a un indirecto cliente mío que consume lo que no nos devuelve a los accionistas como dividendo en pagar hordas de consultores poco avisados de lo que acá cuento.</description>
    </item>
    
    <item>
      <title>Creando paquetes con R: r-forge</title>
      <link>/2010/02/27/creando-paquetes-con-r-r-forge/</link>
      <pubDate>Sat, 27 Feb 2010 19:58:01 +0000</pubDate>
      
      <guid>/2010/02/27/creando-paquetes-con-r-r-forge/</guid>
      <description>Hace poco no asistí a una conferencia del profesor Campo Elías Pardo en la Universidad Nacional de Colombia sobre la creación de paquetes de R. Me penó no poder asistir porque sospeché primero y corroboré después que se había obviado en ella una herramienta muy útil para la creación de paquetes con R: la forja oficial.
La conferencia trababa esencialmente de cómo crear paquetes bajo Windows. Windows es un sistema operativo del que sé poco y siempre me han parecido excesivamente arcanos los liturgias y herramientas necesarias para compilar los paquetes.</description>
    </item>
    
  </channel>
</rss>
