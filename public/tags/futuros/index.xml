<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>futuros on datanalytics</title>
    <link>/tags/futuros/</link>
    <description>Recent content in futuros on datanalytics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Thu, 24 Nov 2016 08:13:35 +0000</lastBuildDate><atom:link href="/tags/futuros/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Habiendo mónadas, ¿quién quiere callbacks?</title>
      <link>/2016/11/24/habiendo-monadas-quien-quiere-callbacks/</link>
      <pubDate>Thu, 24 Nov 2016 08:13:35 +0000</pubDate>
      
      <guid>/2016/11/24/habiendo-monadas-quien-quiere-callbacks/</guid>
      <description>Nunca me he visto en la tesitura de tener que usar callbacks porque no son mi guerra. Pero por lo que he oído de la gente que sabe mucho más que yo, son uno de esos infiernos de los que hay que huir con el mismo pavor que de los fors, los ifs, los elses (¡argggg! ¡he escrito else!) y los whiles.
Una pequeña maravilla teórica que me ha hecho replantearme la absoluta inutilidad de aquello que estudié en Álgebra III (funtores y demás) son las mónadas.</description>
    </item>
    
    <item>
      <title>¿Cuánto tarda en ejecutarse este código?</title>
      <link>/2016/11/11/cuanto-tarda-en-ejecutarse-este-codigo/</link>
      <pubDate>Fri, 11 Nov 2016 08:13:49 +0000</pubDate>
      
      <guid>/2016/11/11/cuanto-tarda-en-ejecutarse-este-codigo/</guid>
      <description>Es:
library(future) plan(multiprocess, workers = 4) system.time({ a1 &amp;lt;- future({Sys.sleep(7); 1}) a2 &amp;lt;- future({Sys.sleep(1); 1}) a3 &amp;lt;- future({Sys.sleep(1); 1}) a4 &amp;lt;- future({Sys.sleep(1); 1}) a5 &amp;lt;- future({Sys.sleep(1); 1}) a6 &amp;lt;- future({Sys.sleep(1); 1}) a7 &amp;lt;- future({Sys.sleep(1); 1}) res &amp;lt;- sapply(list(a1, a2, a3, a4, a5, a6, a5), value) })  Piensa antes las posibles opciones:
 * ~8 segundos: ejecuta primero `a1`-`a4` en 7 segundos y luego `a5`-`a7` en un segundo adicional. * ~7 segundos: ejecuta primero `a1`-`a4`, pero cuando acaban `a2`-`a4`, lanza `a5`-`a7`, que terminan antes que `a1` * ¿Otras?</description>
    </item>
    
    <item>
      <title>R en paralelo (pero ahora, con futuros)</title>
      <link>/2016/11/04/r-en-paralelo-pero-ahora-con-futuros/</link>
      <pubDate>Fri, 04 Nov 2016 08:13:59 +0000</pubDate>
      
      <guid>/2016/11/04/r-en-paralelo-pero-ahora-con-futuros/</guid>
      <description>Esta entrada extiende y mejora una homónima de 2014.
El problema de entonces consistía en calcular por separado y en paralelo objetos A, B y C para combinarlos después. Cuando, por supuesto, el cálculo de A, B y C es pesado.
El muy reciente paquete future incorpora a R un mecanismo disponible en otros lenguajes de programación: un cierto tipo de datos, los futuros, que contienen promesas de valores que se calculan fuera del hilo principal del programa.</description>
    </item>
    
    <item>
      <title>Ingeniería fiscal para mi hipoteca: ¿vendo un futuro?</title>
      <link>/2012/01/03/ingenieria-fiscal-para-mi-hipoteca-%c2%bfvendo-un-futuro/</link>
      <pubDate>Tue, 03 Jan 2012 06:23:30 +0000</pubDate>
      
      <guid>/2012/01/03/ingenieria-fiscal-para-mi-hipoteca-%c2%bfvendo-un-futuro/</guid>
      <description>Tengo una hipoteca. El tipo de interés que pago es el Euribor a 12 meses más un diferencial. He usado una calculadora de hipotecas y he descubierto que si el Euribor sube un 1%, mi cuota (anual, es decir, sumando los incrementos de los 12 meses) se incrementaría en 660 euros.
Y me he preguntado: ¿existe algún producto financiero que me dé dinero si sube el Euribor? ¿Existe alguna manera de protegerme de una subida del índice?</description>
    </item>
    
  </channel>
</rss>
