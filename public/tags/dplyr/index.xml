<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dplyr on datanalytics</title>
    <link>/tags/dplyr/</link>
    <description>Recent content in dplyr on datanalytics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Mon, 05 Aug 2019 09:13:50 +0000</lastBuildDate><atom:link href="/tags/dplyr/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dplyr parece que prefiere los factores</title>
      <link>/2019/08/05/dplyr-parece-que-prefiere-los-factores/</link>
      <pubDate>Mon, 05 Aug 2019 09:13:50 +0000</pubDate>
      
      <guid>/2019/08/05/dplyr-parece-que-prefiere-los-factores/</guid>
      <description>Con datos bajados de aquí:
library(MicroDatosEs) library(dplyr) library(microbenchmark) library(ggplot2) censo &amp;lt;- censo2010(&amp;quot;MicrodatosCP_NV_per_nacional_3VAR.txt&amp;quot;) censo_char &amp;lt;- as.data.frame(censo[, c(&amp;quot;CPRO&amp;quot;, &amp;quot;SEXO&amp;quot;, &amp;quot;ECIVIL&amp;quot;, &amp;quot;FACTOR&amp;quot;)]) censo_factor &amp;lt;- censo_char censo_factor$CPRO &amp;lt;- factor(censo_factor$CPRO) foo &amp;lt;- function(x) x %&amp;gt;% group_by(CPRO) %&amp;gt;% summarise(res = sum((SEXO == &amp;quot;Mujer&amp;quot;) * (ECIVIL == &amp;quot;Divorciado&amp;quot;) * FACTOR) / sum(FACTOR) * 100) res &amp;lt;- microbenchmark( char = foo(censo_char), factor = foo(censo_factor), times = 10 ) autoplot(res)  Da:
¿No es sorprendente? De hecho, plyr es más rápido que dplyr en este caso si no se usan factores.</description>
    </item>
    
    <item>
      <title>Dos nuevos tutoriales sobre data.table y dplyr</title>
      <link>/2016/07/12/dos-nuevos-tutoriales-sobre-data-table-y-dplyr/</link>
      <pubDate>Tue, 12 Jul 2016 08:13:34 +0000</pubDate>
      
      <guid>/2016/07/12/dos-nuevos-tutoriales-sobre-data-table-y-dplyr/</guid>
      <description>Los productos de Apple, aun admitiendo su calidad, resuelven problemas que yo hace años que no tenía. Tanto data.table como dplyr vinieron a resolver problemas a los que muchos nos enfrentábamos con sudor y lágrimas.
Ha aparecido recientemente una serie de tutoriales sobre ambos paquetes que recomiendo:
 * El de [`data.table`](https://rollingyours.wordpress.com/2016/06/14/fast-aggregation-of-large-data-with-the-data-table-package/) * El de `dplyr` ([parte I](https://rollingyours.wordpress.com/2016/06/29/express-intro-to-dplyr/), [parte II](https://rollingyours.wordpress.com/2016/07/07/express-dplyr-part-ii/))  Y mis comentarios:
 * Para el 99% de mis problemas de manipulación de datos, me sobra con, además de R base, `reshape2` y `plyr`.</description>
    </item>
    
    <item>
      <title>¿Cuál es la &#34;mejor&#34; manera de ordenar un dataframe?</title>
      <link>/2015/03/06/cual-es-la-mejor-manera-de-ordenar-un-dataframe/</link>
      <pubDate>Fri, 06 Mar 2015 08:13:04 +0000</pubDate>
      
      <guid>/2015/03/06/cual-es-la-mejor-manera-de-ordenar-un-dataframe/</guid>
      <description>El título de esta entrada es una pregunta honesta. Yo siempre he utilizado order así:
iris[order(iris$Petal.Length),]  Y para ordenar por dos (o más columnas), así:
iris[order(iris$Petal.Length, iris$Petal.Width),]  Es a lo que estoy acostumbrado. Sin embargo, la construcción anterior desconcierta a quienes dan sus primeros pasos en R. dplyr dispone de la función arrange con una sintaxis un tanto más natural:
library(dplyr) arrange(iris, Petal.Length, Petal.Width)  pero, de nuevo, puede resultar desconcertante tener que recurrir a paquetes avanzados: ¿es conveniente introducir a los principiantes en el proceloso mundo de los paquetes para la simple y muy natural operación de ordenar un dataframe?</description>
    </item>
    
    <item>
      <title>plyr, dplyr, data.table: ¿qué opinas?</title>
      <link>/2014/09/24/plyr-dplyr-data-table-que-opinas/</link>
      <pubDate>Wed, 24 Sep 2014 07:13:27 +0000</pubDate>
      
      <guid>/2014/09/24/plyr-dplyr-data-table-que-opinas/</guid>
      <description>Fui un pájaro mañanero con [plyr](http://cran.r-project.org/web/packages/plyr/index.html).
Probé una vez [data.table](http://cran.r-project.org/web/packages/data.table/index.html) y no me convenció. Volví a él cuando realmente lo necesitaba y ahora es la prolongación de mis dedos.
Aún no me he puesto con [dplyr](http://cran.r-project.org/web/packages/dplyr/index.html) aunque he visto el suficiente código escrito con él que no creo que me cueste mucho comenzar a usarlo.
Pero tengo la sensación de que tenemos un cisma como el de vi contra emacs en ciernes.</description>
    </item>
    
    <item>
      <title>Totales agregados por bloques en tablas</title>
      <link>/2014/03/25/totales-agregados-por-bloques-en-tablas/</link>
      <pubDate>Tue, 25 Mar 2014 07:45:50 +0000</pubDate>
      
      <guid>/2014/03/25/totales-agregados-por-bloques-en-tablas/</guid>
      <description>En ocasiones uno quiere añadir un total calculado en ciertos bloques a una tabla. Por ejemplo, en la tabla
&amp;lt;a href=&amp;quot;http://inside-r.org/r-doc/base/set.seed&amp;quot;&amp;gt;set.seed(1234) ventas.orig &amp;lt;- data.frame(cliente = rep(1:10, each = 5), producto = rep(letters[1:5], times = 10), importe = &amp;lt;a href=&amp;quot;http://inside-r.org/r-doc/stats/rlnorm&amp;quot;&amp;gt;rlnorm(50))  tenemos clientes, productos e importes. Y nos preguntamos por el porcentaje en términos de importe que cada producto supone para cada cliente.
Una manera natural pero torpe de realizar este cálculo consiste en usar un objeto intermedio y merge:</description>
    </item>
    
  </channel>
</rss>
