<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>grafos on datanalytics</title>
    <link>/tags/grafos/</link>
    <description>Recent content in grafos on datanalytics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Mon, 27 May 2019 09:13:33 +0000</lastBuildDate><atom:link href="/tags/grafos/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1  3  6 19 30 34  2  7 18 31 33 16  9 27 22 14 11 25 24 12 13 23 26 10 15 21 28  8 17 32  4  5 20 29 35</title>
      <link>/2019/05/27/1-3-6-19-30-34-2-7-18-31-33-16-9-27-22-14-11-25-24-12-13-23-26-10-15-21-28-8-17-32-4-5-20-29-35/</link>
      <pubDate>Mon, 27 May 2019 09:13:33 +0000</pubDate>
      
      <guid>/2019/05/27/1-3-6-19-30-34-2-7-18-31-33-16-9-27-22-14-11-25-24-12-13-23-26-10-15-21-28-8-17-32-4-5-20-29-35/</guid>
      <description>Son los enteros del 1 al 35 ordenados de forma que dos consecutivos en la serie suman un cuadrado perfecto. Los he obtenido así:
library(adagio) foo &amp;lt;- function(n){ desde &amp;lt;- 1:n hasta &amp;lt;- 1:n todos &amp;lt;- expand.grid(desde, hasta) todos &amp;lt;- todos[todos$Var1 &amp;lt; todos$Var2,] todos$sqrt &amp;lt;- sqrt(todos$Var1 + todos$Var2) todos &amp;lt;- todos[todos$sqrt == round(todos$sqrt),] todos$sqrt &amp;lt;- NULL vertices &amp;lt;- as.vector(t(todos)) hamiltonian(vertices) } foo(35)  Notas:
 Esta entrada está inspirada en algo que he visto en Twitter (pero cuya referencia he olvidado guardar).</description>
    </item>
    
    <item>
      <title>qgraph para representar grafos que son correlaciones que son vinos</title>
      <link>/2017/03/15/qgraph-para-representar-grafos-que-son-correlaciones-que-son-vinos/</link>
      <pubDate>Wed, 15 Mar 2017 08:13:37 +0000</pubDate>
      
      <guid>/2017/03/15/qgraph-para-representar-grafos-que-son-correlaciones-que-son-vinos/</guid>
      <description>Me vais a permitir que escriba una entrada sin mayores pretensiones, inspirada en y adaptada de aquí y que sirva solo de que para representar correlaciones entre variables podemos recurrir a los grafos como en
library(qgraph) wine.quality &amp;lt;- read.csv(&amp;quot;https://goo.gl/0Fz1S8&amp;quot;, sep = &amp;quot;;&amp;quot;) qgraph(cor(wine.quality), shape= &amp;quot;circle&amp;quot;, posCol = &amp;quot;darkgreen&amp;quot;, negCol= &amp;quot;darkred&amp;quot;, layout = &amp;quot;groups&amp;quot;, vsize=13)  que pinta
mostrando resumidamente cómo se relacionan entre sí determinadas características de los vinos y cómo en última instancia influyen en su calidad (qlt).</description>
    </item>
    
    <item>
      <title>Onodo: redes para contar historias</title>
      <link>/2016/07/28/onodo-redes-para-contar-historias/</link>
      <pubDate>Thu, 28 Jul 2016 17:13:42 +0000</pubDate>
      
      <guid>/2016/07/28/onodo-redes-para-contar-historias/</guid>
      <description>CartoDB (ahora Carto a secas) lo hizo con mapas. Onodo lo quiere hacer con grafos.
Onodo acaba de salir a la luz de mano de Civio y quiere convertirse en una herramienta para crear muy fácilmente visualizaciones interactivas de redes y nodos, y poder contar historias con ellas. Viene a ser un Gephi digamos que al alcance de (casi) todos, sin el aparataje matemático y orientado a la publicación en la web.</description>
    </item>
    
    <item>
      <title>¿Hay una epidemia en mi grafo?</title>
      <link>/2016/02/26/hay-una-epidemia-en-mi-grafo/</link>
      <pubDate>Fri, 26 Feb 2016 07:13:40 +0000</pubDate>
      
      <guid>/2016/02/26/hay-una-epidemia-en-mi-grafo/</guid>
      <description>Tengo un grafo, g cuyas aristas pueden ser cualquier cosa susceptible de contaminarse. Me pregunto si la contaminación puede contagiarse a través del grafo. Es decir, si A y B están unidos por una arista y A está contaminado, la probabilidad de que B también lo esté es superior a la normal.
Se me ocurre probar esa hipótesis así:
library(igraph) # mi grafo g &amp;lt;- erdos.renyi.game(10000, p.or.m = 0.001, type=&amp;quot;gnp&amp;quot;) min.</description>
    </item>
    
    <item>
      <title>Grafos por vecindad en mapas</title>
      <link>/2015/05/27/grafos-por-vecindad-en-mapas/</link>
      <pubDate>Wed, 27 May 2015 08:13:53 +0000</pubDate>
      
      <guid>/2015/05/27/grafos-por-vecindad-en-mapas/</guid>
      <description>Dando vueltas (infructuosas) al asunto de los cartogramas he dado con un subproducto con el que, por hoy, me conformo: crear un grafo a partir de relaciones de vecindad entre polígonos. La magia, obra de [spdep::poly2nb](http://www.inside-r.org/packages/cran/spdep/docs/poly2nb); el código,
library(&amp;lt;a href=&amp;quot;http://inside-r.org/packages/cran/maptools&amp;quot;&amp;gt;maptools) library(&amp;lt;a href=&amp;quot;http://inside-r.org/packages/cran/spdep&amp;quot;&amp;gt;spdep) library(igraph) # fichero descargado del INE aragon &amp;lt;- readShapePoly(&amp;quot;ccaa00c02.shp&amp;quot;) plot(aragon)  
aragon.nb &amp;lt;- poly2nb(aragon) # vértices vertices &amp;lt;- aragon@data vertices$id &amp;lt;- 1:nrow(aragon@data) vertices &amp;lt;- vertices[, c(&amp;quot;id&amp;quot;, setdiff(colnames(vertices), &amp;quot;id&amp;quot;))] # coordenadas aproximadas de los vértices my.</description>
    </item>
    
    <item>
      <title>Componentes conexas (de grafos) en Spark</title>
      <link>/2014/09/15/componentes-conexas-de-grafos-en-spark/</link>
      <pubDate>Mon, 15 Sep 2014 07:13:46 +0000</pubDate>
      
      <guid>/2014/09/15/componentes-conexas-de-grafos-en-spark/</guid>
      <description>Uno de mis últimos pet projects tiene que ver con el análisis de las componentes conexas de unos grafos muy grandes. Como aquí pero con datos de un tamaño muchos órdenes de magnitud mayores. Usando Spark, claro. Y ya que lo cito, aprovecho la ocasión para regalar un consejo a mis lectores más jóvenes: no esperéis a los cuarenta para aprender Scala y Spark.
Voy a limitarme a copiar el código para referencia mía y de otros.</description>
    </item>
    
    <item>
      <title>60 generaciones</title>
      <link>/2014/07/28/60-generaciones/</link>
      <pubDate>Mon, 28 Jul 2014 07:13:00 +0000</pubDate>
      
      <guid>/2014/07/28/60-generaciones/</guid>
      <description>Tú eres un conjunto de cardinalidad 1. Tú y tus padres conformáis un conjunto de cardinalidad 3. Añade a tus abuelos y tendrás un conjunto de cardinalidad 7. Aplica la inducción y tendrás conjuntos de cardinalidad $latex 2^n -1$.
Esto viene a cuenta de lo que me contó un colega el otro día: que en Corea tiene un libro en el que aparecen sus ancestros desde 54 generaciones atrás. Yo le pregunté cómo almacenaba esos 18014398509481983 nombres.</description>
    </item>
    
  </channel>
</rss>
