<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>future on datanalytics</title>
    <link>/tags/future/</link>
    <description>Recent content in future on datanalytics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Thu, 24 Nov 2016 08:13:35 +0000</lastBuildDate><atom:link href="/tags/future/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Habiendo mónadas, ¿quién quiere callbacks?</title>
      <link>/2016/11/24/habiendo-monadas-quien-quiere-callbacks/</link>
      <pubDate>Thu, 24 Nov 2016 08:13:35 +0000</pubDate>
      
      <guid>/2016/11/24/habiendo-monadas-quien-quiere-callbacks/</guid>
      <description>Nunca me he visto en la tesitura de tener que usar callbacks porque no son mi guerra. Pero por lo que he oído de la gente que sabe mucho más que yo, son uno de esos infiernos de los que hay que huir con el mismo pavor que de los fors, los ifs, los elses (¡argggg! ¡he escrito else!) y los whiles.
Una pequeña maravilla teórica que me ha hecho replantearme la absoluta inutilidad de aquello que estudié en Álgebra III (funtores y demás) son las mónadas.</description>
    </item>
    
    <item>
      <title>¿Cuánto tarda en ejecutarse este código?</title>
      <link>/2016/11/11/cuanto-tarda-en-ejecutarse-este-codigo/</link>
      <pubDate>Fri, 11 Nov 2016 08:13:49 +0000</pubDate>
      
      <guid>/2016/11/11/cuanto-tarda-en-ejecutarse-este-codigo/</guid>
      <description>Es:
library(future) plan(multiprocess, workers = 4) system.time({ a1 &amp;lt;- future({Sys.sleep(7); 1}) a2 &amp;lt;- future({Sys.sleep(1); 1}) a3 &amp;lt;- future({Sys.sleep(1); 1}) a4 &amp;lt;- future({Sys.sleep(1); 1}) a5 &amp;lt;- future({Sys.sleep(1); 1}) a6 &amp;lt;- future({Sys.sleep(1); 1}) a7 &amp;lt;- future({Sys.sleep(1); 1}) res &amp;lt;- sapply(list(a1, a2, a3, a4, a5, a6, a5), value) })  Piensa antes las posibles opciones:
 * ~8 segundos: ejecuta primero `a1`-`a4` en 7 segundos y luego `a5`-`a7` en un segundo adicional. * ~7 segundos: ejecuta primero `a1`-`a4`, pero cuando acaban `a2`-`a4`, lanza `a5`-`a7`, que terminan antes que `a1` * ¿Otras?</description>
    </item>
    
  </channel>
</rss>
